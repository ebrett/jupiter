{
  "tasks": [
    {
      "id": 1,
      "title": "Rails Project Setup and Infrastructure",
      "description": "Set up the Rails 8 project with Hotwire, Stimulus, and TailwindCSS",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Initialize Rails 8 project, configure Hotwire, Stimulus, and TailwindCSS. Set up PostgreSQL database, configure development environment, and establish basic project structure.",
      "testStrategy": "Verify Rails server starts, Hotwire/Stimulus functionality, and database connectivity",
      "subtasks": [
        {
          "id": 1,
          "title": "Initialize Rails 8 Project with PostgreSQL",
          "description": "Create a new Rails 8 project with PostgreSQL as the database and set up the basic project structure",
          "dependencies": [],
          "details": "Run `rails new project_name --database=postgresql --css=tailwind` to create a new Rails 8 project. Configure database.yml for development, test, and production environments. Run initial database setup with `rails db:create`. Set up .gitignore file and initialize Git repository.",
          "status": "done",
          "testStrategy": "Verify Rails server starts successfully with `rails server`. Confirm database connection with `rails db:migrate:status`."
        },
        {
          "id": 2,
          "title": "Configure Hotwire and Stimulus",
          "description": "Set up and configure Hotwire (Turbo and Stimulus) for dynamic frontend interactions",
          "dependencies": [
            1
          ],
          "details": "Add Hotwire gems to Gemfile if not included by default. Install Stimulus by running `rails stimulus:install`. Create a basic Stimulus controller to verify setup. Configure Turbo Drive, Frames, and Streams in application.js. Set up ActionCable for Turbo Streams if needed.",
          "status": "done",
          "testStrategy": "Create a simple Stimulus controller test that manipulates DOM elements. Verify Turbo Drive navigation between pages works correctly."
        },
        {
          "id": 3,
          "title": "Set up TailwindCSS Configuration",
          "description": "Configure and customize TailwindCSS for the application's styling needs",
          "dependencies": [
            1
          ],
          "details": "Verify TailwindCSS installation from Rails new command. Create tailwind.config.js with appropriate content paths. Set up custom theme configuration including colors, fonts, and spacing. Configure PostCSS if needed. Create base application styles in app/assets/stylesheets/application.tailwind.css. Set up purging for production.\n<info added on 2025-05-15T08:41:02.926Z>\nImplementation plan for TailwindCSS configuration:\n\n1. Verify TailwindCSS installation from Rails new command (should be included if using `rails new project_name --database=postgresql --css=tailwind`).\n   - Check for tailwindcss-rails gem in Gemfile\n   - Confirm presence of tailwind.config.js file\n\n2. If not installed, add TailwindCSS:\n   - Run: `bundle add tailwindcss-rails`\n   - Run: `rails tailwindcss:install`\n\n3. Create or update tailwind.config.js:\n   - Configure content paths to include all relevant directories:\n     ```js\n     content: [\n       './app/views/**/*.html.erb',\n       './app/helpers/**/*.rb',\n       './app/javascript/**/*.js',\n       './app/assets/stylesheets/**/*.css'\n     ]\n     ```\n   - Set up custom theme configuration:\n     - Define brand colors\n     - Configure typography (font families, sizes)\n     - Adjust spacing scale if needed\n\n4. Configure PostCSS if needed for additional plugins beyond what Rails provides.\n\n5. Create or update app/assets/stylesheets/application.tailwind.css:\n   - Ensure it includes the required Tailwind directives:\n     ```css\n     @tailwind base;\n     @tailwind components;\n     @tailwind utilities;\n     ```\n   - Add any custom component classes using @apply\n\n6. Set up purging for production (should be automatic with Rails integration).\n\n7. Test the configuration:\n   - Create a test page with various Tailwind utility classes\n   - Verify custom theme values are applied correctly\n   - Check responsive design utilities\n\n8. Commit all changes to Git before proceeding to the next task.\n\nPotential challenges to watch for:\n- Missing content paths leading to purged styles in production\n- Custom theme values not being applied correctly\n- Build issues in development or production environments\n</info added on 2025-05-15T08:41:02.926Z>",
          "status": "done",
          "testStrategy": "Create a test page with various Tailwind utility classes to verify styling is applied correctly. Check that custom theme values are working."
        },
        {
          "id": 4,
          "title": "Configure Development Environment",
          "description": "Set up comprehensive development environment with debugging tools, testing framework, and CI pipeline",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Configure RSpec, Factory Bot, and other testing gems. Set up debugging tools like debug gem or Pry. Configure linting with RuboCop. Set up CI pipeline configuration (GitHub Actions or similar). Create development seeds with `rails db:seed`. Configure environment variables with dotenv or credentials. Set up Docker development environment if needed.\n<info added on 2025-05-15T09:26:34.121Z>\n## Implementation Plan\n\n1. Add and configure RSpec for testing:\n   - Add `rspec-rails` to the Gemfile (group :development, :test)\n   - Run `bundle install`\n   - Run `rails generate rspec:install`\n   - Verify generated files: `.rspec`, `spec/rails_helper.rb`, `spec/spec_helper.rb`\n\n2. Add Factory Bot for test data:\n   - Add `factory_bot_rails` to the Gemfile (group :development, :test)\n   - Configure RSpec to use Factory Bot syntax in `spec/rails_helper.rb`\n   - Create initial factory definitions in `spec/factories/` directory\n\n3. Set up debugging tools:\n   - Add `pry-rails` or `debug` gem to the Gemfile (group :development, :test)\n   - Configure initialization in `.pryrc` if using Pry\n\n4. Configure RuboCop for linting:\n   - Add `rubocop`, `rubocop-rails`, and `rubocop-rspec` to the Gemfile\n   - Run `bundle install`\n   - Create `.rubocop.yml` with Rails style guide configurations\n   - Add common exclusions and custom rules as needed\n\n5. Set up CI pipeline with GitHub Actions:\n   - Create directory structure `.github/workflows/`\n   - Add `ci.yml` with jobs for:\n     - Running tests (`bundle exec rspec`)\n     - Running linters (`bundle exec rubocop`)\n     - Checking security vulnerabilities (`bundle audit`)\n\n6. Create development seeds:\n   - Enhance `db/seeds.rb` with realistic development data\n   - Structure seeds to be idempotent (can be run multiple times)\n   - Add seed data for all major models in the application\n   - Run `rails db:seed` to populate development database\n\n7. Configure environment variables:\n   - Add `dotenv-rails` to the Gemfile\n   - Create `.env.example` with template variables (no real values)\n   - Add `.env` to `.gitignore`\n   - Document required environment variables in README\n   - Use `rails credentials:edit` for sensitive production credentials\n\n8. Set up Docker for development (optional):\n   - Create `Dockerfile` for Rails application\n   - Create `docker-compose.yml` for Rails, PostgreSQL, and Redis\n   - Add Docker-specific configuration files (entrypoint scripts, etc.)\n   - Document Docker setup and commands in README\n\n9. Testing the setup:\n   - Run complete test suite with `bundle exec rspec`\n   - Verify linting works with `bundle exec rubocop`\n   - Test CI pipeline locally or with a test commit\n   - Verify seed data loads correctly\n\n10. Documentation and finalization:\n    - Update README with setup instructions\n    - Document any custom configurations\n    - Commit all changes to Git\n\nPotential challenges:\n- Ensuring consistent environments across team members\n- CI pipeline configuration for all required services\n- Managing secrets securely\n- Docker configuration complexity\n\nNext steps:\n- After verifying the development environment, proceed to security configuration (task 1.5)\n</info added on 2025-05-15T09:26:34.121Z>",
          "status": "done",
          "testStrategy": "Run the test suite to verify RSpec is configured correctly. Verify linting works with sample code. Test seed data loads correctly."
        },
        {
          "id": 5,
          "title": "Implement Basic Security Configuration",
          "description": "Set up security measures including authentication framework, CSRF protection, and secure headers",
          "dependencies": [
            1,
            4
          ],
          "details": "Configure strong parameters in controllers. Set up CSRF protection in ApplicationController. Add secure headers configuration. Configure Content Security Policy. Set up basic authentication framework (Devise or similar if needed). Configure Rails credentials for sensitive information. Add Brakeman for security scanning.",
          "status": "done",
          "testStrategy": "Run Brakeman to check for security vulnerabilities. Write tests to verify CSRF protection is working. Test authentication flow if implemented."
        }
      ]
    },
    {
      "id": 2,
      "title": "Nationbuilder OAuth Integration",
      "description": "Implement OAuth authentication with Nationbuilder in Rails",
      "status": "pending",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Set up OAuth integration with Nationbuilder API using Rails OAuth gems, implement single sign-on, and handle user data synchronization. Configure secure token storage and session management.",
      "testStrategy": "Test authentication flow, token management, and user data synchronization",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up Nationbuilder OAuth configuration",
          "description": "Register the application with Nationbuilder to obtain OAuth credentials and configure the Rails application to use these credentials.",
          "dependencies": [],
          "details": "1. Register the application in Nationbuilder developer portal\n2. Obtain client ID and client secret\n3. Create an initializer file (config/initializers/nationbuilder.rb) to store configuration\n4. Use Rails credentials or environment variables to securely store OAuth keys\n5. Install required gems: 'omniauth', 'omniauth-oauth2', and create a custom Nationbuilder OAuth strategy",
          "status": "pending",
          "testStrategy": "Create tests to verify configuration is loaded correctly and environment variables are properly accessed"
        },
        {
          "id": 2,
          "title": "Implement OAuth authentication flow",
          "description": "Create the necessary controllers and routes to handle the OAuth authentication flow with Nationbuilder.",
          "dependencies": [
            1
          ],
          "details": "1. Create OmniauthCallbacksController to handle Nationbuilder callbacks\n2. Set up routes for authentication (/auth/nationbuilder and /auth/nationbuilder/callback)\n3. Implement the authentication request method that redirects to Nationbuilder\n4. Handle the callback from Nationbuilder after user authorizes\n5. Implement error handling for failed authentication attempts",
          "status": "pending",
          "testStrategy": "Write controller tests that mock OAuth callbacks and verify proper handling of success and failure scenarios"
        },
        {
          "id": 3,
          "title": "Implement user data synchronization",
          "description": "Create a service to fetch and synchronize user data from Nationbuilder after successful authentication.",
          "dependencies": [
            2
          ],
          "details": "1. Create a NationbuilderUserService class to handle API interactions\n2. Implement methods to fetch user profile data from Nationbuilder API\n3. Create or update local user records based on Nationbuilder data\n4. Map Nationbuilder user attributes to local user model attributes\n5. Handle edge cases like missing data or API failures",
          "status": "pending",
          "testStrategy": "Create unit tests for the service with mocked API responses and integration tests that verify user data is properly synchronized"
        },
        {
          "id": 4,
          "title": "Implement secure token storage and refresh",
          "description": "Create a secure mechanism to store OAuth tokens and implement token refresh functionality.",
          "dependencies": [
            2
          ],
          "details": "1. Add columns to User model for storing encrypted access_token, refresh_token, and token_expiry\n2. Implement encryption/decryption for token storage using Rails built-in encryption\n3. Create a TokenRefreshService to handle automatic token refresh when expired\n4. Implement background job to periodically check and refresh tokens before expiry\n5. Add error handling for failed token refreshes",
          "status": "pending",
          "testStrategy": "Test encryption/decryption of tokens, token refresh logic with mocked API responses, and verify tokens are properly updated in the database"
        },
        {
          "id": 5,
          "title": "Implement single sign-on functionality",
          "description": "Create the necessary components to enable single sign-on between the Rails application and Nationbuilder.",
          "dependencies": [
            3,
            4
          ],
          "details": "1. Modify the SessionsController to handle SSO login/logout\n2. Implement a mechanism to check if user is already authenticated in Nationbuilder\n3. Create helper methods to generate SSO URLs for Nationbuilder\n4. Implement sign-out that logs user out of both systems\n5. Add session management to maintain consistent authentication state",
          "status": "pending",
          "testStrategy": "Create integration tests that verify the full SSO flow, including login and logout functionality across both systems"
        }
      ]
    },
    {
      "id": 3,
      "title": "User Role Management with Rails",
      "description": "Implement role-based access control system using Rails",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Create role management system using Rails models and controllers. Implement six distinct roles (Submitter, Country/Chapter Admin, Treasury Team Admin, Super Admin, Viewer, Treasury IT) with proper authorization using Rails policies.",
      "testStrategy": "Verify role permissions and access controls through Rails test suite",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Role Model and Database Schema",
          "description": "Design and implement the Role model and necessary database schema to support the six distinct roles (Submitter, Country/Chapter Admin, Treasury Team Admin, Super Admin, Viewer, Treasury IT).",
          "dependencies": [],
          "details": "Create a Role model with appropriate attributes (name, description, permissions). Set up a join table for user-role associations. Generate and run migrations to create the necessary database tables. Include seed data for the six predefined roles.",
          "status": "pending",
          "testStrategy": "Write unit tests for the Role model validations and associations. Create factory for roles using FactoryBot."
        },
        {
          "id": 2,
          "title": "Implement User-Role Associations",
          "description": "Set up the association between Users and Roles, allowing users to be assigned one or multiple roles.",
          "dependencies": [
            1
          ],
          "details": "Update the User model with a has_many :roles association through a join table. Add methods to check if a user has a specific role (e.g., user.has_role?(:admin)). Implement methods to assign and remove roles from users. Update user forms/views to allow role assignment.",
          "status": "pending",
          "testStrategy": "Test user-role associations with unit tests. Verify role assignment and removal functionality works correctly."
        },
        {
          "id": 3,
          "title": "Create Authorization Policies with Pundit",
          "description": "Implement Pundit policies to handle authorization based on user roles.",
          "dependencies": [
            2
          ],
          "details": "Install and configure the Pundit gem. Create policy classes for each resource that needs role-based access control. Define permissions for each role in the policies. Implement policy scopes to filter collections based on user roles. Ensure policies handle all six roles correctly.",
          "status": "pending",
          "testStrategy": "Write policy specs to test authorization rules for each role. Test both allowed and forbidden actions for different user roles."
        },
        {
          "id": 4,
          "title": "Implement Role Management UI",
          "description": "Create admin interface for managing roles and assigning roles to users.",
          "dependencies": [
            2,
            3
          ],
          "details": "Create controllers and views for role management (index, show, edit, update). Implement user search and bulk role assignment features. Add role filtering and sorting capabilities. Ensure the interface is accessible only to users with appropriate permissions (Super Admin). Include confirmation dialogs for critical role changes.",
          "status": "pending",
          "testStrategy": "Write system/integration tests using Capybara to verify the role management UI works correctly. Test role assignment, removal, and permission changes."
        },
        {
          "id": 5,
          "title": "Integrate Role-Based Access Control with Views and Controllers",
          "description": "Apply role-based access control throughout the application by updating views and controllers to respect user permissions.",
          "dependencies": [
            3
          ],
          "details": "Update controllers to use Pundit for authorization checks. Modify views to show/hide elements based on user roles. Add before_action filters to restrict access to controllers/actions. Implement custom error pages for authorization failures. Add role-specific navigation menus and dashboards for each role type.",
          "status": "pending",
          "testStrategy": "Write integration tests to verify that users with different roles see appropriate UI elements and can access only authorized features. Test authorization failures and redirects."
        }
      ]
    },
    {
      "id": 4,
      "title": "Request Creation System with Hotwire",
      "description": "Build the core request creation and management system using Rails and Hotwire",
      "status": "pending",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "Implement request creation interface using Rails forms and Hotwire for real-time updates. Create draft saving functionality and request submission workflow. Use Stimulus for form interactions and TailwindCSS for styling.",
      "testStrategy": "Test request creation, saving, and submission flows with system tests",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Request Model and Database Schema",
          "description": "Design and implement the Request model with appropriate attributes, validations, and associations. Set up the database schema with migrations.",
          "dependencies": [],
          "details": "Create a Request model with attributes like title, description, status (draft/submitted), user_id, and any other relevant fields. Add validations for required fields. Create database migrations to set up the schema. Implement associations with User model if applicable. Add enum for request status handling.",
          "status": "pending",
          "testStrategy": "Write model tests for validations and associations. Test database constraints and enum functionality."
        },
        {
          "id": 2,
          "title": "Implement Request Form with Stimulus",
          "description": "Build the request creation form using Rails form helpers and enhance with Stimulus controllers for dynamic interactions.",
          "dependencies": [],
          "details": "Create a form partial with Rails form_with helper. Implement Stimulus controllers for form validation, character counting, and dynamic field behavior. Style the form using TailwindCSS with responsive design. Include error handling and client-side validations. Add ARIA attributes for accessibility.",
          "status": "pending",
          "testStrategy": "Write system tests for form submission, validation errors, and Stimulus interactions."
        },
        {
          "id": 3,
          "title": "Develop Draft Saving Functionality",
          "description": "Implement automatic draft saving for requests in progress using Hotwire and background processing.",
          "dependencies": [],
          "details": "Create a Stimulus controller that detects form changes and triggers draft saves via fetch requests. Implement a controller action to handle draft updates. Use Turbo Streams to update the UI with save status without page refreshes. Add debounce functionality to prevent excessive saves. Implement draft retrieval when users return to an incomplete form.",
          "status": "pending",
          "testStrategy": "Test automatic saving with different timing scenarios. Verify draft persistence across page reloads and browser sessions."
        },
        {
          "id": 4,
          "title": "Build Request Submission Workflow",
          "description": "Implement the complete submission flow for requests, including validation, confirmation, and status updates.",
          "dependencies": [],
          "details": "Create a submission controller action that validates and processes the final request. Implement a confirmation modal using Stimulus. Add server-side validations for submission requirements. Use Turbo Streams to update the UI after submission. Implement flash notifications for submission status. Add hooks for any post-submission processes like notifications.",
          "status": "pending",
          "testStrategy": "Test the full submission workflow including validation failures and successful submissions. Verify status changes and redirects."
        },
        {
          "id": 5,
          "title": "Implement Real-time Request List with Turbo Frames",
          "description": "Create a real-time updating list of requests using Turbo Frames and Streams for immediate UI updates.",
          "dependencies": [],
          "details": "Build a requests index view with Turbo Frames for each request item. Implement Turbo Streams broadcasts for real-time updates when requests are created, updated, or deleted. Add filtering and sorting capabilities using Stimulus controllers. Style the list with TailwindCSS, including responsive design for mobile views. Implement pagination if needed.",
          "status": "pending",
          "testStrategy": "Test real-time updates with multiple browser sessions. Verify sorting and filtering functionality. Test pagination if implemented."
        }
      ]
    },
    {
      "id": 5,
      "title": "Request Approval Workflow with Hotwire",
      "description": "Implement the request approval and processing system using Rails and Hotwire",
      "status": "pending",
      "dependencies": [
        4
      ],
      "priority": "high",
      "details": "Build approval interface for Country/Chapter admins using Hotwire for real-time updates. Implement notification system using Action Cable. Create Treasury processing workflow with proper authorization.",
      "testStrategy": "Verify approval workflow and notification system with integration tests",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Request Approval Data Models",
          "description": "Design and implement the database models for the approval workflow system, including requests, approvals, and status tracking.",
          "dependencies": [],
          "details": "Create Rails models for Request, Approval, and related entities. Include associations between Users, Country/Chapter admins, and Treasury roles. Implement state machine for request status (pending, approved, rejected, processing). Add validations and scopes for filtering requests by status and ownership.",
          "status": "pending",
          "testStrategy": "Write model tests for validations, associations, and state transitions. Use FactoryBot to create test fixtures."
        },
        {
          "id": 2,
          "title": "Build Admin Approval Interface with Turbo Frames",
          "description": "Implement the UI for Country/Chapter admins to view, filter, and approve/reject requests using Hotwire Turbo Frames for seamless updates.",
          "dependencies": [
            1
          ],
          "details": "Create controller actions for listing, filtering, and updating requests. Design Turbo Frame-based views with request cards that can be updated in-place. Implement approve/reject buttons that trigger Turbo Stream updates. Add filtering by status, date, and requester. Include pagination for request lists.",
          "status": "pending",
          "testStrategy": "Write system tests using Capybara to verify the approval workflow. Test real-time updates with Turbo Frames."
        },
        {
          "id": 3,
          "title": "Implement Real-time Notifications with Action Cable",
          "description": "Create a notification system using Action Cable to alert users about request status changes and admin actions.",
          "dependencies": [
            1,
            2
          ],
          "details": "Set up Action Cable channels for notifications. Create a Notification model to store user notifications. Implement broadcast callbacks on Request model state changes. Build a notification UI component with Turbo Streams for real-time updates. Add notification preferences for users.",
          "status": "pending",
          "testStrategy": "Test Action Cable broadcasts with integration tests. Verify notification delivery and display in the UI."
        },
        {
          "id": 4,
          "title": "Develop Treasury Processing Workflow",
          "description": "Build the interface and business logic for Treasury staff to process approved requests with proper authorization controls.",
          "dependencies": [
            1,
            2
          ],
          "details": "Create Treasury-specific controller and views. Implement processing steps (review, payment initiation, completion). Add authorization using Pundit policies to restrict actions to Treasury roles. Build audit logging for all Treasury actions. Implement batch processing capabilities for multiple requests.",
          "status": "pending",
          "testStrategy": "Write authorization tests to verify role-based access. Test the complete processing workflow with integration tests."
        },
        {
          "id": 5,
          "title": "Add Email Notifications and Activity History",
          "description": "Implement email notifications for key workflow events and create an activity history log for each request.",
          "dependencies": [
            1,
            3,
            4
          ],
          "details": "Create mailers for request status changes (created, approved, rejected, processed). Implement an ActivityLog model to track all actions on requests. Build a timeline view using Turbo Frames to display the activity history. Add email preference settings for users. Implement background job processing for emails using Sidekiq.",
          "status": "pending",
          "testStrategy": "Test email delivery with ActionMailer tests. Verify activity logging with model and integration tests."
        }
      ]
    },
    {
      "id": 6,
      "title": "Payment Processing System",
      "description": "Develop the payment processing and tracking system using Rails",
      "status": "pending",
      "dependencies": [
        5
      ],
      "priority": "high",
      "details": "Create payment status tracking using Rails models. Implement payment metadata fields and prepare for future QuickBooks integration. Use Hotwire for real-time status updates.",
      "testStrategy": "Test payment processing workflow and status updates",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Payment Model and Database Schema",
          "description": "Design and implement the Payment model with all necessary attributes for tracking payment status and metadata fields required for QuickBooks integration.",
          "dependencies": [],
          "details": "Create a Payment model with attributes like amount, status (pending, processing, completed, failed), payment_method, transaction_id, customer_id, invoice_id, and metadata fields (json column). Add appropriate validations, associations with other models (e.g., User, Order), and indexes for performance. Run migrations to set up the database schema.",
          "status": "pending",
          "testStrategy": "Write unit tests for model validations, associations, and scopes. Ensure the database schema properly handles all required data types."
        },
        {
          "id": 2,
          "title": "Implement Payment Status State Machine",
          "description": "Create a state machine to manage payment status transitions and ensure data integrity during the payment lifecycle.",
          "dependencies": [
            1
          ],
          "details": "Use the AASM gem to implement a state machine for the Payment model. Define states (pending, processing, completed, failed, refunded) and transitions between them. Add callbacks for logging status changes and triggering notifications. Implement guard conditions to prevent invalid transitions.",
          "status": "pending",
          "testStrategy": "Test all possible state transitions, including valid and invalid paths. Verify callbacks are triggered correctly when states change."
        },
        {
          "id": 3,
          "title": "Build Payment Processing Service",
          "description": "Create a service object to handle payment processing logic, including integration with payment gateways and error handling.",
          "dependencies": [
            2
          ],
          "details": "Implement a PaymentProcessingService class that encapsulates payment gateway interactions. Design it to be payment provider agnostic with adapter patterns for different gateways. Include methods for processing payments, refunds, and verifying payment status. Add comprehensive error handling and logging. Structure the code to facilitate future QuickBooks integration.",
          "status": "pending",
          "testStrategy": "Write unit tests with mocked payment gateway responses. Test happy paths and various error scenarios. Ensure the service properly updates payment status in the database."
        },
        {
          "id": 4,
          "title": "Create Payment Controller and Views",
          "description": "Implement the controller actions and views for payment processing, history, and management.",
          "dependencies": [
            3
          ],
          "details": "Create a PaymentsController with actions for new, create, show, index, and refund. Implement views for payment form, payment confirmation, payment details, and payment history. Add proper error handling and user feedback. Ensure proper authorization checks using Pundit or CanCanCan. Include filtering and sorting options for payment history.",
          "status": "pending",
          "testStrategy": "Write controller tests for all actions. Test authorization rules. Create system tests for the payment flow from initiation to completion."
        },
        {
          "id": 5,
          "title": "Implement Real-time Payment Status Updates with Hotwire",
          "description": "Use Hotwire to provide real-time payment status updates to users without page refreshes.",
          "dependencies": [
            2,
            4
          ],
          "details": "Set up Turbo Streams to broadcast payment status changes. Create partials for different payment states. Update the Payment model to broadcast changes using callbacks. Implement a dashboard component that subscribes to payment updates. Add visual indicators for different payment statuses (pending, processing, completed, failed). Ensure proper error handling for connection issues.",
          "status": "pending",
          "testStrategy": "Write system tests that simulate payment status changes and verify the UI updates accordingly. Test with different browsers to ensure compatibility."
        }
      ]
    },
    {
      "id": 7,
      "title": "Reporting and Analytics with Rails",
      "description": "Implement reporting and analytics features using Rails",
      "status": "pending",
      "dependencies": [
        6
      ],
      "priority": "medium",
      "details": "Build request listing with sorting/filtering using Rails scopes. Create detailed request views with proper authorization. Implement summary overview for Treasury using Rails views and Stimulus for interactivity.",
      "testStrategy": "Verify reporting functionality and data accuracy with system tests",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Request Listing with Sorting and Filtering",
          "description": "Create a paginated request listing view with sorting and filtering capabilities using Rails scopes",
          "dependencies": [],
          "details": "Define Rails scopes in the Request model for filtering by status, date range, and request type. Implement controller actions to handle sorting parameters. Create a view with sortable column headers and filter form. Use Kaminari or will_paginate for pagination. Ensure proper SQL optimization for performance.",
          "status": "pending",
          "testStrategy": "Write controller tests for different filter combinations. Test scope methods with unit tests. Verify pagination works correctly with different page sizes."
        },
        {
          "id": 2,
          "title": "Build Detailed Request View with Authorization",
          "description": "Create a detailed view for individual requests with proper authorization checks",
          "dependencies": [
            1
          ],
          "details": "Implement a show action in the RequestsController with proper authorization using Pundit or CanCanCan. Design a detailed view template showing all request attributes, history, and status. Add conditional rendering based on user roles. Implement breadcrumbs for navigation back to the listing.",
          "status": "pending",
          "testStrategy": "Test authorization rules for different user roles. Verify all request data is displayed correctly. Test navigation between listing and detail views."
        },
        {
          "id": 3,
          "title": "Create Summary Dashboard for Treasury",
          "description": "Implement a dashboard view with summary statistics and charts for Treasury users",
          "dependencies": [
            1
          ],
          "details": "Create a DashboardController with actions for Treasury users. Implement data aggregation methods to calculate summary statistics (total requests, amounts by status, etc.). Design a dashboard view with cards for key metrics. Use Chartkick or similar for basic charts. Ensure proper authorization for Treasury-only access.",
          "status": "pending",
          "testStrategy": "Test dashboard calculations for accuracy. Verify authorization prevents non-Treasury users from accessing. Test with various data scenarios to ensure charts render correctly."
        },
        {
          "id": 4,
          "title": "Add Interactive Filtering with Stimulus",
          "description": "Enhance the listing and dashboard with interactive filtering using Stimulus.js",
          "dependencies": [
            1,
            3
          ],
          "details": "Create Stimulus controllers for filter forms and charts. Implement debounced filter inputs that update results without full page reloads. Add date range pickers with Stimulus integration. Implement controller endpoints that respond to both HTML and JSON formats. Use Turbo Frames or Turbo Streams for partial page updates.",
          "status": "pending",
          "testStrategy": "Write system tests with Capybara to verify interactive filtering. Test JavaScript functionality with Jest. Verify proper behavior with and without JavaScript enabled."
        },
        {
          "id": 5,
          "title": "Implement Data Export Functionality",
          "description": "Add functionality to export filtered request data in CSV and PDF formats",
          "dependencies": [
            1,
            2
          ],
          "details": "Extend the RequestsController to handle CSV and PDF format requests. Use CSV library for CSV generation with proper header formatting. Implement PDF generation using Prawn or Wicked PDF. Create a service object to encapsulate export logic. Add export buttons to the listing view with proper styling. Include all relevant fields and respect current filters in exports.",
          "status": "pending",
          "testStrategy": "Test CSV and PDF generation with various data sets. Verify file downloads work correctly. Check that filters are respected in exported data. Test with large datasets to ensure performance."
        }
      ]
    },
    {
      "id": 8,
      "title": "Admin Dashboard with Hotwire",
      "description": "Create comprehensive admin interface using Rails and Hotwire",
      "status": "pending",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "Build user management interface using Rails admin patterns. Implement system configuration options and create role mapping interface. Use Hotwire for real-time updates and Stimulus for interactive features.",
      "testStrategy": "Test admin functionality and configuration options",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up Admin Dashboard Layout and Authentication",
          "description": "Create the basic admin dashboard layout with navigation and ensure proper authentication/authorization for admin users",
          "dependencies": [],
          "details": "Create an admin namespace in routes.rb, implement admin controller with before_action to verify admin permissions, design responsive layout with sidebar navigation using Tailwind CSS, and implement admin-specific authentication checks",
          "status": "pending",
          "testStrategy": "Write system tests to verify admin authentication flow and access restrictions for non-admin users"
        },
        {
          "id": 2,
          "title": "Implement User Management Interface with Hotwire",
          "description": "Build CRUD interface for managing users with real-time updates using Hotwire Turbo Frames and Streams",
          "dependencies": [
            1
          ],
          "details": "Create users controller in admin namespace, implement index view with pagination and filtering, build new/edit forms within Turbo Frames, add user deletion with confirmation modals, and implement Turbo Streams for real-time updates when users are created/updated/deleted",
          "status": "pending",
          "testStrategy": "Test CRUD operations with system tests, verify Turbo Frame and Stream functionality with JavaScript-enabled tests"
        },
        {
          "id": 3,
          "title": "Create Role Management System with Stimulus",
          "description": "Implement interface for creating and assigning roles to users with interactive features using Stimulus",
          "dependencies": [
            2
          ],
          "details": "Create Role model with many-to-many relationship to users, build role CRUD interface, implement role assignment UI with Stimulus controllers for drag-and-drop functionality, add permission toggles for each role, and ensure proper validation",
          "status": "pending",
          "testStrategy": "Test role creation, editing, and assignment workflows, verify Stimulus controllers with JavaScript-enabled tests"
        },
        {
          "id": 4,
          "title": "Build System Configuration Interface",
          "description": "Create interface for managing system-wide configuration options with real-time validation",
          "dependencies": [
            1
          ],
          "details": "Implement Settings model/table for storing configuration, create configuration controller and views, use Stimulus for real-time validation of settings, implement Turbo Frames for inline editing of configuration values, and add configuration categories/grouping",
          "status": "pending",
          "testStrategy": "Test configuration saving/loading, verify validation rules work correctly, ensure settings persist correctly"
        },
        {
          "id": 5,
          "title": "Implement Admin Dashboard Analytics and Activity Log",
          "description": "Create dashboard overview with key metrics and activity log showing recent admin actions",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Build dashboard controller and view with summary cards for key metrics, implement activity logging for all admin actions, create activity feed with Turbo Streams for real-time updates, add basic charts using Chartkick, and implement date range filtering",
          "status": "pending",
          "testStrategy": "Test activity logging mechanism, verify dashboard displays correct metrics, ensure real-time updates work properly"
        }
      ]
    },
    {
      "id": 9,
      "title": "Testing and Quality Assurance",
      "description": "Implement comprehensive testing suite for Rails application",
      "status": "pending",
      "dependencies": [
        7,
        8
      ],
      "priority": "high",
      "details": "Create unit tests, integration tests, and system tests using Rails testing framework. Implement Hotwire and Stimulus tests. Set up continuous integration pipeline.",
      "testStrategy": "Run test suite and verify coverage",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up RSpec and testing environment",
          "description": "Configure RSpec, FactoryBot, and other testing dependencies for the Rails application",
          "dependencies": [],
          "details": "Install and configure RSpec, FactoryBot, and other necessary gems. Set up database cleaner for test environment. Create test helpers and shared examples. Configure test database and ensure proper isolation between test runs.",
          "status": "pending",
          "testStrategy": "Verify configuration by running a simple test to ensure the testing environment is properly set up."
        },
        {
          "id": 2,
          "title": "Implement model and controller unit tests",
          "description": "Create comprehensive unit tests for all models and controllers in the application",
          "dependencies": [],
          "details": "Write tests for model validations, associations, scopes, and custom methods. Create controller tests for all actions, ensuring proper response status, template rendering, and JSON responses where applicable. Use FactoryBot to create test data and stubs/mocks where appropriate.",
          "status": "pending",
          "testStrategy": "Aim for at least 90% code coverage for models and controllers. Use SimpleCov to track coverage metrics."
        },
        {
          "id": 3,
          "title": "Develop integration tests for key workflows",
          "description": "Create integration tests that verify the interaction between different components of the application",
          "dependencies": [],
          "details": "Identify critical user workflows and create integration tests that verify these paths work correctly. Test form submissions, AJAX requests, and multi-step processes. Ensure proper data persistence and state changes throughout the workflow.",
          "status": "pending",
          "testStrategy": "Use request specs to test API endpoints and feature specs with Capybara for browser-based workflows."
        },
        {
          "id": 4,
          "title": "Implement Hotwire and Stimulus tests",
          "description": "Create specialized tests for Hotwire (Turbo and Stimulus) functionality",
          "dependencies": [],
          "details": "Set up testing environment for JavaScript components using Stimulus. Create tests for Turbo Frames, Turbo Streams, and Stimulus controllers. Verify proper DOM updates, event handling, and state management. Use tools like stimulus_reflex_testing if applicable.",
          "status": "pending",
          "testStrategy": "Use system tests with JavaScript enabled to verify Hotwire functionality. Consider using Jest for unit testing Stimulus controllers."
        },
        {
          "id": 5,
          "title": "Set up CI/CD pipeline with GitHub Actions",
          "description": "Configure continuous integration and deployment pipeline using GitHub Actions",
          "dependencies": [],
          "details": "Create GitHub Actions workflow files to run tests automatically on push and pull requests. Configure the pipeline to run different test suites (unit, integration, system). Set up test reporting and notifications for failed builds. Integrate with code quality tools like RuboCop and Brakeman.",
          "status": "pending",
          "testStrategy": "Verify CI pipeline by intentionally introducing a failing test, then fixing it to ensure the pipeline correctly identifies and reports issues."
        }
      ]
    },
    {
      "id": 10,
      "title": "Documentation and Deployment",
      "description": "Create documentation and prepare for Rails deployment",
      "status": "pending",
      "dependencies": [
        9
      ],
      "priority": "medium",
      "details": "Write technical documentation for Rails application. Create user guides. Prepare deployment configuration for Rails environment. Document Hotwire and Stimulus usage patterns.",
      "testStrategy": "Review documentation and verify deployment process",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Technical Documentation for Rails Application",
          "description": "Develop comprehensive technical documentation covering the Rails application architecture, database schema, API endpoints, and key components.",
          "dependencies": [],
          "details": "Create a markdown-based technical documentation that includes: system architecture diagram, database ERD, API endpoint documentation with request/response examples, authentication flow, and third-party integrations. Store documentation in a 'docs/technical' directory within the project.",
          "status": "pending",
          "testStrategy": "Have another developer review the documentation for clarity and completeness. Verify all diagrams accurately represent the current system."
        },
        {
          "id": 2,
          "title": "Document Hotwire and Stimulus Usage Patterns",
          "description": "Create detailed documentation on how Hotwire (Turbo and Stimulus) is implemented throughout the application, including common patterns and best practices.",
          "dependencies": [
            1
          ],
          "details": "Document all Stimulus controllers with their actions and targets. Create examples of Turbo Frames and Turbo Streams usage in the application. Include code snippets demonstrating common patterns. Document the real-time features implemented with Hotwire. Store in 'docs/technical/hotwire_patterns.md'.",
          "status": "pending",
          "testStrategy": "Validate documentation against actual implementation. Ensure all Stimulus controllers are documented and examples are functional."
        },
        {
          "id": 3,
          "title": "Develop User Guides and Documentation",
          "description": "Create user-facing documentation including installation guides, user manuals, and feature walkthroughs for different user roles.",
          "dependencies": [
            1
          ],
          "details": "Develop user guides for each user role (admin, regular user, etc.). Include screenshots and step-by-step instructions for common tasks. Create an installation guide for local development setup. Document environment variables and configuration options. Store in 'docs/user_guides' directory.",
          "status": "pending",
          "testStrategy": "Have non-technical users review guides for clarity. Verify installation guide by following it on a clean environment."
        },
        {
          "id": 4,
          "title": "Prepare Deployment Configuration",
          "description": "Set up deployment configuration files for different environments (staging, production) and document the deployment process.",
          "dependencies": [
            1
          ],
          "details": "Create deployment configuration files for different environments. Set up Capistrano or similar deployment tool. Configure environment variables for production. Set up database migration scripts for deployment. Document SSL certificate setup and renewal process. Create a deployment checklist in 'docs/deployment/deployment_checklist.md'.",
          "status": "pending",
          "testStrategy": "Test deployment to a staging environment to verify configuration works correctly."
        },
        {
          "id": 5,
          "title": "Create Maintenance and Troubleshooting Guide",
          "description": "Develop documentation for ongoing maintenance, monitoring, and troubleshooting of the deployed application.",
          "dependencies": [
            3,
            4
          ],
          "details": "Document monitoring setup and alerting configuration. Create troubleshooting guides for common issues. Document backup and restore procedures. Include performance optimization tips. Document log locations and common error patterns. Create runbook for incident response in 'docs/maintenance/runbook.md'.",
          "status": "pending",
          "testStrategy": "Review with DevOps team to ensure all critical maintenance procedures are covered. Validate troubleshooting steps for known issues."
        }
      ]
    },
    {
      "id": 11,
      "title": "Implement Idempotent Seed Data for Major Models",
      "description": "Create realistic, idempotent seed data for all major models, ensuring seeds can be run multiple times without duplication. Explicitly include the creation of test users for development and QA purposes, covering a variety of user roles and realistic data. Document the process in the README, and ensure the seed process is updated as new models are added.",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "details": "For each major model in the application, define a set of realistic sample records in the seed file(s). Use idempotent patterns such as `find_or_create_by` or equivalent logic to ensure that running the seed process multiple times does not result in duplicate records or data corruption. Where appropriate, update existing records with new attributes to keep seed data current. Consider extracting common seed logic into helper methods for maintainability. Ensure that all relationships and dependencies between models are respected in the seed data. Explicitly create a diverse set of test users for development and QA, covering all user roles and using realistic data. Add clear documentation to the README explaining how to run the seeds, the idempotency guarantees, and how to extend or modify the seed data as models evolve. Establish a process to evaluate all new models as they are created to determine if they require seed data, and update the seed process accordingly.",
      "testStrategy": "1. Run the seed process on a clean database and verify that all expected records, including test users with various roles, are created with correct attributes and relationships. 2. Run the seed process multiple times and confirm that no duplicate records are created and existing records are updated as intended. 3. Manually inspect the database or use automated tests to ensure data integrity and idempotency. 4. Review the README to ensure the seed process is clearly documented and instructions are accurate. 5. When new models are added, verify that the evaluation process determines if seed data is needed and updates are made as appropriate.",
      "subtasks": [
        {
          "id": 1,
          "title": "Analyze and document all major models requiring seed data",
          "description": "Identify all major models in the application that require seed data, including their relationships and dependencies.",
          "dependencies": [],
          "details": "Create a comprehensive list of all major models in the application. For each model, document its attributes, validations, associations, and any special requirements. Identify dependency chains between models (e.g., Users must exist before Posts). Create a dependency graph to visualize the order in which models should be seeded. Document any existing seed data patterns already in use.",
          "status": "pending",
          "testStrategy": "Review the documentation with team members to ensure all major models are included and dependencies are correctly identified."
        },
        {
          "id": 2,
          "title": "Design idempotent seeding patterns and helper methods",
          "description": "Create reusable helper methods and patterns for idempotent data seeding that can be applied across all models.",
          "dependencies": [
            1
          ],
          "details": "Implement helper methods for common seeding patterns like `find_or_create_by`, `find_or_initialize_by` with attribute updates, and unique constraint handling. Create methods for generating consistent test data (names, emails, dates, etc.) that won't change between seed runs. Design patterns for handling associations in an idempotent way. Implement error handling and logging for seed operations. Consider using transactions where appropriate to ensure data consistency.",
          "status": "pending",
          "testStrategy": "Write unit tests for helper methods to verify idempotency by running the same seed operation multiple times and checking for consistent results."
        },
        {
          "id": 3,
          "title": "Implement seed data for primary models",
          "description": "Create seed data for primary models (those with no dependencies on other models) using the idempotent patterns.",
          "dependencies": [
            2
          ],
          "details": "Using the dependency graph from subtask 1, identify all primary models (those with no dependencies). For each primary model, implement seed data using the helper methods from subtask 2. Create a diverse set of realistic records for each model. Include edge cases and boundary conditions where appropriate. Add comments explaining the purpose of each seed record or group. Ensure all required attributes are populated with realistic values.",
          "status": "pending",
          "testStrategy": "Run the seed process multiple times and verify that no duplicate records are created. Check that the database contains exactly the expected number of records for each model."
        },
        {
          "id": 4,
          "title": "Implement seed data for dependent models",
          "description": "Create seed data for all remaining models with dependencies, ensuring proper relationship handling.",
          "dependencies": [
            3
          ],
          "details": "Following the dependency order from subtask 1, implement seed data for all remaining models. Use the helper methods from subtask 2 to ensure idempotency. Reference existing records from primary models when creating associated records. Handle many-to-many relationships appropriately. Ensure foreign key constraints are satisfied. Create a diverse set of relationship patterns (e.g., users with many posts, users with no posts, etc.). Test complex relationship chains to ensure they're correctly established.",
          "status": "pending",
          "testStrategy": "Verify that all relationships are correctly established by querying the database after seeding. Check that running seeds multiple times maintains relationship integrity."
        },
        {
          "id": 5,
          "title": "Document seed process in README and create verification script",
          "description": "Update the project README with comprehensive documentation about the seed process and create a verification script to validate seed data.",
          "dependencies": [
            4
          ],
          "details": "Add a dedicated section to the README explaining how to run the seed process. Document the idempotency guarantees and how they're implemented. Explain how to extend or modify seed data as models evolve. Include examples of common seed data modifications. Create a verification script that can be run to validate the seed data is correct and complete. The script should check for expected record counts, verify key relationships, and ensure no orphaned records exist. Add the verification script to the CI pipeline if applicable.",
          "status": "pending",
          "testStrategy": "Have a team member follow the README instructions to run the seed process on a clean database and verify the results match expectations."
        },
        {
          "id": 6,
          "title": "Create diverse test users for development and QA",
          "description": "Add seed data for test users covering all user roles and realistic scenarios for development and QA purposes.",
          "dependencies": [
            2
          ],
          "details": "Define a set of test users with a variety of roles (e.g., admin, regular user, QA, guest) and realistic attributes (names, emails, etc.). Ensure these users are created idempotently using the established helper methods. Document the purpose and credentials of these users in the README for easy reference by developers and QA engineers.",
          "status": "pending",
          "testStrategy": "After seeding, verify that all test users exist with correct roles and attributes. Run the seed process multiple times to confirm no duplicates are created and user data remains consistent."
        },
        {
          "id": 7,
          "title": "Evaluate new models for seed data requirements",
          "description": "Establish and follow a process to review all new models as they are created to determine if they require seed data, and update the seed files and documentation accordingly.",
          "dependencies": [],
          "details": "For every new model introduced to the application, assess whether seed data is needed for development, QA, or production environments. If so, add appropriate seed data using idempotent patterns and update the documentation to reflect the change. Ensure this evaluation is part of the model creation workflow.",
          "status": "pending",
          "testStrategy": "Review recent model additions to confirm that each has been evaluated for seed data needs and that the seed files and documentation are kept up to date."
        }
      ]
    },
    {
      "id": 12,
      "title": "Implement OAuth2 Authorization Code Flow with Refresh Token Handling for Nationbuilder V2 API",
      "description": "Develop a complete OAuth2 implementation for the Nationbuilder V2 API that handles both initial authorization and automatic token refresh, ensuring continuous API access without requiring user re-authentication.",
      "details": "This task requires implementing the full OAuth2 authorization code flow and refresh token mechanism for the Nationbuilder V2 API integration. Key implementation details include:\n\n1. **Initial Authorization Flow**:\n   - Create OAuth2 client configuration with appropriate scopes for Nationbuilder V2 API\n   - Implement authorization request endpoint that redirects users to Nationbuilder\n   - Create callback handler to process authorization codes\n   - Exchange authorization code for initial access and refresh tokens\n   - Store both tokens securely in the database with user association and expiration metadata\n\n2. **Token Refresh Mechanism**:\n   - Implement token expiration detection (access tokens expire after 24 hours)\n   - Create a service to handle automatic refresh token exchange\n   - Update the stored tokens after successful refresh\n   - Implement proper error handling for refresh failures\n\n3. **API Request Handling**:\n   - Create a request wrapper that verifies token validity before making API calls\n   - Automatically trigger refresh flow when access token is expired\n   - Retry failed requests with new tokens when appropriate\n\n4. **Error Handling**:\n   - Handle invalid/expired refresh tokens\n   - Manage user revocation scenarios\n   - Implement graceful fallbacks when refresh fails\n   - Add appropriate logging for debugging authentication issues\n\n5. **Security Considerations**:\n   - Ensure tokens are stored securely (encrypted if necessary)\n   - Implement proper token rotation and management\n   - Follow OAuth2 security best practices\n\n6. **Code Organization**:\n   - Create reusable OAuth2 client services\n   - Separate authentication logic from API business logic\n   - Design for testability with dependency injection\n\nThe implementation should be robust enough to handle all common OAuth2 edge cases while providing a seamless experience for users.",
      "testStrategy": "Testing for this OAuth2 implementation should be comprehensive and cover all aspects of the authorization and refresh flows:\n\n1. **Unit Tests**:\n   - Test token storage and retrieval mechanisms\n   - Verify token expiration detection logic\n   - Test refresh token service in isolation with mocked responses\n   - Validate error handling for various failure scenarios\n\n2. **Integration Tests**:\n   - Create tests that mock the Nationbuilder OAuth endpoints\n   - Verify the full authorization code flow from request to token storage\n   - Test the refresh token flow with simulated expired access tokens\n   - Ensure API requests properly detect expired tokens and trigger refresh\n\n3. **Mock Server Tests**:\n   - Set up a mock OAuth2 server that simulates Nationbuilder's behavior\n   - Test against this server to verify correct request/response handling\n   - Simulate various error conditions (invalid tokens, server errors)\n\n4. **End-to-End Tests**:\n   - Create a sandbox Nationbuilder account for testing if possible\n   - Verify the complete flow works against the actual API\n   - Test the user experience through the authorization process\n\n5. **Specific Test Cases**:\n   - Successful initial authorization and token storage\n   - Successful token refresh when access token expires\n   - Failed refresh due to invalid refresh token\n   - Failed refresh due to revoked access\n   - API call with valid token\n   - API call with expired token that triggers refresh\n   - Concurrent API calls handling token refresh properly\n   - Edge cases like network failures during refresh\n\n6. **Test Fixtures and Helpers**:\n   - Create fixtures for various token states (valid, expired, etc.)\n   - Implement time manipulation helpers to test expiration without waiting\n\nAll tests should be automated and included in the CI pipeline to ensure ongoing functionality.",
      "status": "in-progress",
      "dependencies": [],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement OAuth2 Client Configuration and Initial Authorization Flow",
          "description": "Create the OAuth2 client configuration and implement the initial authorization flow that redirects users to Nationbuilder for authentication and handles the callback with authorization code.",
          "dependencies": [],
          "details": "1. Create an OAuth2Client class with configuration parameters (client_id, client_secret, redirect_uri, scopes)\n2. Implement an authorization URL generator method that builds the proper Nationbuilder authorization URL with required parameters\n3. Create an endpoint in the application that redirects users to this authorization URL\n4. Implement a callback handler endpoint that receives the authorization code from Nationbuilder\n5. Add appropriate error handling for authorization failures\n6. Use environment variables for sensitive OAuth configuration\n<info added on 2025-05-21T13:26:43.584Z>\nImplementation Plan and Code Structure for OAuth2 Client Configuration and Initial Authorization Flow:\n\n**Files/Components:**\n- app/services/oauth2_client.rb: Service class for OAuth2 logic (client_id, client_secret, redirect_uri, scopes, authorization_url)\n- app/controllers/nationbuilder_auth_controller.rb: Controller for OAuth endpoints (redirect and callback actions)\n- config/routes.rb: Add routes for /auth/nationbuilder and /auth/nationbuilder/callback\n- .env: Store NATIONBUILDER_CLIENT_ID, NATIONBUILDER_CLIENT_SECRET, NATIONBUILDER_REDIRECT_URI\n- (Optional) config/initializers/nationbuilder_oauth.rb: Centralize config loading if needed\n\n**Key Steps:**\n1. Oauth2Client service: builds authorization URL from ENV/config\n2. Controller: redirect action sends user to Nationbuilder, callback action handles code/error\n3. Routes: map /auth/nationbuilder and /auth/nationbuilder/callback\n4. All secrets/config from ENV, never hardcoded\n5. Error handling for missing/invalid params and OAuth errors\n\n**Testing:**\n- Unit test Oauth2Client#authorization_url for correct URL generation\n- Integration test controller flow with mocks\n\n**Potential Challenges:**\n- Ensuring correct redirect URI registration with Nationbuilder\n- Handling all error cases gracefully\n\nThis plan covers the structure and initial implementation approach for subtask 12.1. Next step: implement the service, controller, and routes as described.\n</info added on 2025-05-21T13:26:43.584Z>",
          "status": "done",
          "testStrategy": "Unit test the URL generation with different scopes. Mock the OAuth endpoints for integration tests. Create a test harness that simulates the full authorization flow."
        },
        {
          "id": 2,
          "title": "Implement Token Exchange and Secure Storage",
          "description": "Develop the functionality to exchange the authorization code for access and refresh tokens, and implement secure storage of these tokens in the database.",
          "dependencies": [
            1
          ],
          "details": "1. Create a token exchange service that calls Nationbuilder token endpoint with authorization code\n2. Parse and validate the token response (access_token, refresh_token, expires_in, etc.)\n3. Design a database schema for securely storing tokens with user association\n4. Implement encryption for token storage if required by security policy\n5. Store tokens with metadata including expiration time, scope, and user information\n6. Create methods to retrieve and validate stored tokens",
          "status": "done",
          "testStrategy": "Mock the token exchange API for testing. Verify token encryption/decryption works correctly. Test database operations with a test database instance."
        },
        {
          "id": 3,
          "title": "Implement Token Refresh Mechanism",
          "description": "Create a service that detects token expiration and automatically refreshes access tokens using the stored refresh tokens.",
          "dependencies": [
            2
          ],
          "details": "1. Implement a token validation method that checks if access tokens are expired\n2. Create a token refresh service that exchanges refresh tokens for new access tokens\n3. Update the stored tokens after successful refresh\n4. Implement retry logic with exponential backoff for failed refresh attempts\n5. Add event hooks for successful and failed token refreshes\n6. Create a background job or middleware that proactively refreshes tokens approaching expiration",
          "status": "done",
          "testStrategy": "Test token expiration detection with tokens at various lifecycle stages. Mock refresh API responses including success and various failure scenarios. Test the retry mechanism with forced failures."
        },
        {
          "id": 4,
          "title": "Create API Request Wrapper with Token Management",
          "description": "Develop a request wrapper for the Nationbuilder V2 API that verifies token validity before making API calls and handles token refresh when needed.",
          "dependencies": [
            3
          ],
          "details": "1. Create an API client class that wraps all Nationbuilder V2 API requests\n2. Implement request interceptors that check token validity before each request\n3. Automatically trigger the refresh flow when an access token is expired\n4. Handle 401/403 responses by attempting token refresh and retrying the request\n5. Implement request queuing during active token refresh to prevent multiple simultaneous refresh attempts\n6. Add appropriate request/response logging for debugging",
          "status": "in-progress",
          "testStrategy": "Create mock API endpoints that simulate various response scenarios. Test the automatic refresh on 401 responses. Verify request retry behavior works correctly after token refresh."
        },
        {
          "id": 5,
          "title": "Implement Comprehensive Error Handling and Recovery",
          "description": "Develop robust error handling for all OAuth2 edge cases including invalid/expired refresh tokens, user revocation scenarios, and network failures.",
          "dependencies": [
            4
          ],
          "details": "1. Create specific error classes for different OAuth2 failure scenarios\n2. Implement handlers for invalid/expired refresh tokens that trigger re-authentication\n3. Add detection and handling for user-revoked access\n4. Create a notification system for authentication failures that require user intervention\n5. Implement graceful degradation of functionality when authentication cannot be restored automatically\n6. Add detailed logging for all authentication events for audit and debugging purposes\n7. Create admin dashboard components to monitor OAuth2 token status across users",
          "status": "pending",
          "testStrategy": "Test each error scenario with mocked API responses. Verify the system correctly identifies different error types. Test the re-authentication flow triggers correctly for non-recoverable errors."
        },
        {
          "id": 6,
          "title": "Documentation and Developer Onboarding for OAuth2 Flow",
          "description": "Document the OAuth2 and refresh token implementation for Nationbuilder V2. Include setup instructions, environment/configuration requirements, usage examples, and troubleshooting tips for developers. Ensure onboarding is clear for new team members.",
          "details": "",
          "status": "pending",
          "dependencies": [
            5
          ],
          "parentTaskId": 12
        },
        {
          "id": 7,
          "title": "CI/CD Integration for OAuth2 and Token Refresh Flow",
          "description": "Integrate tests for the OAuth2 and refresh token flow into the CI/CD pipeline. Ensure all relevant unit, integration, and end-to-end tests are run automatically on each commit and pull request. Add checks for token management and error handling coverage.",
          "details": "",
          "status": "pending",
          "dependencies": [
            5
          ],
          "parentTaskId": 12
        },
        {
          "id": 8,
          "title": "User Experience and UI for Authentication and Token Errors",
          "description": "Design and implement user-facing UI/UX for authentication and token error scenarios. This includes clear error messages, re-authentication prompts, and guidance for users when access is lost or needs to be restored. Ensure a seamless and informative experience for all authentication flows.",
          "details": "",
          "status": "pending",
          "dependencies": [
            5
          ],
          "parentTaskId": 12
        }
      ]
    },
    {
      "id": 13,
      "title": "Implement Robust and Idempotent Test User Seeding Mechanism",
      "description": "Develop a reusable, idempotent seeding mechanism to create test user accounts with various roles and realistic data for local development and QA workflows.",
      "details": "Design and implement a dedicated seeding module or service responsible for creating test users with diverse roles (e.g., admin, standard user, QA, etc.) and realistic attributes (names, emails, profile data). Ensure the seeding logic is idempotentrunning the seed multiple times should not create duplicate users or alter existing test users unexpectedly. Use unique identifiers (such as email addresses) to check for existing users before creation. Structure the seed data to cover a range of scenarios relevant to development and QA, including edge cases. Integrate the seeding process into the development workflow via a script or command (e.g., `npm run seed` or a Rails task), and document usage and customization options. Follow best practices for managing object relationships and dependencies to ensure referential integrity and maintainability. Consider using configuration or environment variables to control which users or roles are seeded in different environments.",
      "testStrategy": "Verify that running the seeding mechanism multiple times does not create duplicate users or modify existing seeded users unexpectedly. Check that all expected user roles and data variations are present in the database after seeding. Test the seeding process in both a clean and pre-populated database state. Review logs or output for errors or warnings. Confirm that seeded users can be used for authentication and authorization in development and QA workflows. Ensure documentation is clear and up to date, and that the seeding process can be triggered easily by developers and QA engineers.",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "subtasks": []
    }
  ],
  "metadata": {
    "projectName": "Reimbursement and Vendor Payment Web Application",
    "version": "1.0.0",
    "lastUpdated": "2024-03-21",
    "techStack": "Rails 8, Hotwire, Stimulus, TailwindCSS, PostgreSQL"
  }
}